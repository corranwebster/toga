from __future__ import annotations

import warnings
from collections.abc import Iterable, Mapping
from typing import Any, Literal, Protocol, TypeVar

import toga
from toga.handlers import wrapped_handler
from toga.sources import AccessorColumn, ColumnT, Node, Source, TreeSource, TreeSourceT
from toga.style import Pack

from .base import Widget

Value = TypeVar("Value", contravariant=False, covariant=False)


class OnSelectHandler(Protocol):
    def __call__(self, widget: Tree, **kwargs: Any) -> None:
        """A handler to invoke when the tree is selected.

        :param widget: The Tree that was selected.
        :param kwargs: Ensures compatibility with arguments added in future versions.
        """


class OnActivateHandler(Protocol):
    def __call__(self, widget: Tree, **kwargs: Any) -> None:
        """A handler to invoke when the tree is activated.

        :param widget: The Tree that was activated.
        :param kwargs: Ensures compatibility with arguments added in future versions.
        """


class Tree(Widget):
    def __init__(
        self,
        columns: Iterable[str | ColumnT[Value]] | None = None,
        id: str | None = None,
        style: Pack | None = None,
        data: TreeSourceT | object | None = None,
        accessors: Iterable[str] | None = None,
        multiple_select: bool = False,
        on_select: toga.widgets.tree.OnSelectHandler | None = None,
        on_activate: toga.widgets.tree.OnActivateHandler | None = None,
        missing_value: str = "",
        *,
        show_headings: bool | None = None,
        headings: Iterable[str] | None = None,
        **kwargs,
    ):
        """Create a new Tree widget.

        :param columns: The column objects or heading strings for the tree.
            Column objects must implement the ['ColumnT'][toga.sources.ColumnT]
            protocol. Heading strings will be converted to
            ['AccessorColumn'][toga.sources.AccessorColumn] instances
            automatically. Heading strings can only contain one line; any text after a
            newline will be ignored.

            A value of [`None`][] will produce a tree without headings.
            However, if you do this, you *must* give a list of accessors.

        :param id: The ID for the widget.
        :param style: A style object. If no style is provided, a default style will be
            applied to the widget.
        :param data: Initial [`data`][toga.Tree.data] to be displayed in the tree.

        :param accessors: [Deprecated] When the data is provided as an iterable, the
            `TreeSource` created by the Tree will try to derive its accessors from the
            Columns.  However in some cases this may need to be overridden, for example
            if there should be more accessors than columns, or when the attribute for a
            column given as a heading string doesn't match the string.

            The `accessors` argument must be either:

            * `None` to derive all accessors from the columns; or

            * A list at least as long as `columns`, specifying the accessors for each
              column and any additional accessors needed.  When the column is given by
              a heading string then the heading and accessor will be used to create an
              [`AccessorColumn`][toga.sources.AccessorColumn]; or

            * A dictionary mapping heading strings to accessors. When the column is
              given by a heading string then the heading and accessor will be used to
              create an [`AccessorColumn`][toga.sources.AccessorColumn].  Any
              missing headings will fall back to the default generated accessor.

            If no columns or heading strings were provided, an
            ['AccessorColumn'][toga.sources.AccessorColumn] instance will be
            created for each accessor and a tree with no headings will be created.

            The accessors are also passed to any `TreeSources` created by the Tree to
            tell the source how to map lists and tuples to accessor values. This
            ordering does not change even when columns are added or removed.

        :param multiple_select: Does the tree allow multiple selection?
        :param on_select: Initial [`on_select`][toga.Tree.on_select] handler.
        :param on_activate: Initial [`on_activate`][toga.Tree.on_activate] handler.
        :param missing_value: The string that will be used to populate a cell when the
            value provided by its accessor is [`None`][], or the accessor isn't
            defined.
        :param show_headings: Whether or not to show headings at the top of the tree.
            For backwards compatibility, this is set to False if no columns or headings
            are provided.
        :param headings: [Deprecated] A list of heading strings for columns.
        :param kwargs: Initial style properties.
        """
        self._data: TreeSourceT | TreeSource

        self._missing_value = missing_value if missing_value else ""
        self._multiple_select = multiple_select

        ######################################################################
        # 2026-02: Backwards compatibility for <= 0.5.3
        ######################################################################
        if headings is not None:
            if columns is None:
                warnings.warn(
                    "The 'headings' keyword argument is deprecated, "
                    "use 'columns' instead.",
                    DeprecationWarning,
                    stacklevel=2,
                )
                columns = headings
            else:
                raise TypeError("Can't specify columns and headings at the same time.")
        if accessors is not None:
            warnings.warn(
                "The `accessors` argument is deprecated. To specify a non-default "
                "accessor for a column, use an AccessorColumn. To specify the "
                "ordering of accessors use a `TreeSource` with an `accessors` "
                "argument for the data.",
                DeprecationWarning,
                stacklevel=2,
            )

        if columns is None:
            if accessors is None:
                raise ValueError(
                    "Cannot create a tree without either columns or accessors."
                )
            columns = AccessorColumn.columns_from_headings_and_accessors(
                None, accessors
            )
            if show_headings is None:
                # Don't show headings if only given accessors.
                show_headings = False
        elif isinstance(accessors, Mapping):
            columns = [
                AccessorColumn(column, accessors.get(column, None))
                if isinstance(column, str)
                else column
                for column in columns
            ]
        elif accessors is not None:
            columns = [
                AccessorColumn(column, accessor) if isinstance(column, str) else column
                for column, accessor in zip(columns, accessors, strict=False)
            ]
        ######################################################################
        # End backwards compatibility
        ######################################################################
        else:
            columns = [
                AccessorColumn(column) if isinstance(column, str) else column
                for column in columns
            ]

        ######################################################################
        # 2026-02: Backwards compatibility for <= 0.5.3
        #
        # When removing backwards compatibility for accessors, show_headings can
        # default to True, and this logic can be removed.
        ######################################################################
        self._show_headings = show_headings if show_headings is not None else True
        ######################################################################
        # End backwards compatibility
        ######################################################################

        self._columns: list[ColumnT] = columns

        # Prime some properties that need to exist before the tree is created.
        self.on_select = None
        self.on_activate = None

        super().__init__(id, style, **kwargs)

        if not isinstance(data, Source):
            if accessors is None or isinstance(accessors, Mapping):
                # Use the column's accessors
                accessor_order = [
                    column.accessor
                    for column in columns
                    if getattr(column, "accessor", None) is not None
                ]
            else:
                # use the accessors parameter
                accessor_order = list(accessors)

            if data is None:
                data = TreeSource(accessors=accessor_order, data=[])
            else:
                data = TreeSource(accessors=accessor_order, data=data)

        self.data = data

        self.on_select = on_select
        self.on_activate = on_activate

    def _create(self):
        return self.factory.Tree(interface=self)

    @property
    def enabled(self) -> Literal[True]:
        """Is the widget currently enabled? i.e., can the user interact with the widget?
        Tree widgets cannot be disabled; this property will always return True; any
        attempt to modify it will be ignored.
        """
        return True

    @enabled.setter
    def enabled(self, value: object) -> None:
        pass

    @property
    def data(self) -> TreeSourceT | TreeSource:
        """The data to display in the tree.

        When setting this property:

        * A [`Source`][toga.sources.Source] will be used as-is. It must either be a
        [`TreeSource`][toga.sources.TreeSource], or
          a custom class that provides the same methods.

        * A value of None is turned into an empty TreeSource.

        * Otherwise, the value must be a dictionary or an iterable, which is copied
          into a new TreeSource as shown [here][treesource-item].

        In the last two cases, when creating a new or empty TreeSource, the
        accessors of the old source are copied to the new one or, if that is
        impossible, the accessors of the columns are used.
        """
        return self._data

    @data.setter
    def data(self, data: TreeSourceT | object | None) -> None:
        old_data = getattr(self, "_data", None)
        if old_data is not None:
            self._data.remove_listener(self._impl)

        if data is None:
            data = []
        if isinstance(data, Source):
            self._data = data
        else:
            # try to copy the accessors from the previous data source
            accessors = getattr(old_data, "accessors", None)
            if accessors is None:
                # failing that, use the accessors from the columns, if any
                accessors = [
                    column.accessor
                    for column in self.columns
                    if getattr(column, "accessor", None) is not None
                ]
            self._data = TreeSource(accessors=accessors, data=data)

        self._data.add_listener(self._impl)
        self._impl.change_source(source=self._data)

    @property
    def multiple_select(self) -> bool:
        """Does the tree allow multiple rows to be selected?"""
        return self._multiple_select

    @property
    def selection(self) -> list[Node] | Node | None:
        """The current selection of the tree.

        If multiple selection is enabled, returns a list of Node objects from the data
        source matching the current selection. An empty list is returned if no nodes are
        selected.

        If multiple selection is *not* enabled, returns the selected Node object, or
        [`None`][] if no node is currently selected.
        """
        return self._impl.get_selection()

    def expand(self, node: Node | None = None) -> None:
        """Expand the specified node of the tree.

        If no node is provided, all nodes of the tree will be expanded.

        If the provided node is a leaf node, or the node is already expanded, this is a
        no-op.

        If a node is specified, the children of that node will also be expanded.

        :param node: The node to expand
        """
        if node is None:
            self._impl.expand_all()
        else:
            self._impl.expand_node(node)

    def collapse(self, node: Node | None = None) -> None:
        """Collapse the specified node of the tree.

        If no node is provided, all nodes of the tree will be collapsed.

        If the provided node is a leaf node, or the node is already collapsed,
        this is a no-op.

        :param node: The node to collapse
        """
        if node is None:
            self._impl.collapse_all()
        else:
            self._impl.collapse_node(node)

    def append_column(
        self,
        column: ColumnT[Value] | str | None = None,
        accessor: str | None = None,
        *,
        heading: str | None = None,
    ) -> None:
        """Append a column to the end of the tree.

        :param column: The new column, or a heading string for the new column.
        :param accessor: An accessor to use if a heading string is supplied rather
            than a column object. If not specified, an accessor will be derived from
            the heading. An accessor *must* be specified if the column is None.
        """
        ######################################################################
        # 2026-02: Backwards compatibility for <= 0.5.3
        ######################################################################
        if heading is not None:
            if column is None:
                warnings.warn(
                    "The 'heading' keyword argument is deprecated, "
                    "use 'column' instead.",
                    DeprecationWarning,
                    stacklevel=2,
                )
                column = heading
            else:
                raise TypeError("Can't specify both 'column' and 'heading' arguments.")
        ######################################################################
        # End backwards compatibility
        ######################################################################
        self.insert_column(len(self._columns), column, accessor=accessor)

    def insert_column(
        self,
        index: int | ColumnT[Value] | str,
        column: ColumnT[Value] | str | None = None,
        accessor: str | None = None,
        *,
        heading: str | None = None,
    ) -> None:
        """Insert an additional column into the tree.

        :param index: The index at which to insert the column, or the column (or its
            accessor [Deprecated]) before which the new column should be inserted.
        :param column: The new column, or a heading string for the new column.
        :param accessor: [Deprecated] An accessor to use if a heading string is
            supplied rather than a column object. If not specified, an accessor will
            be derived from the heading. An accessor *must* be specified if the
            column is None.
        """
        ######################################################################
        # 2026-02: Backwards compatibility for <= 0.5.3
        ######################################################################
        if heading is not None:
            if column is None:
                warnings.warn(
                    "The 'heading' keyword argument is deprecated, "
                    "use 'column' instead.",
                    DeprecationWarning,
                    stacklevel=2,
                )
                column = heading
            else:
                raise TypeError("Can't specify both 'column' and 'heading' arguments.")
        ######################################################################
        # End backwards compatibility
        ######################################################################
        if column is None and accessor is None:
            raise ValueError("Must specify either a column or an accessor.")
        elif isinstance(column, str) and not self._show_headings and accessor is None:
            raise ValueError("Must specify an accessor on a tree without headings.")
        elif isinstance(column, str) or column is None:
            column = AccessorColumn(column, accessor)
        elif accessor is not None:
            warnings.warn(
                "The 'accessor' argument is ignored when a column object is supplied.",
                stacklevel=2,
            )

        ######################################################################
        # 2026-02: Backwards compatibility for <= 0.5.3
        ######################################################################
        if isinstance(index, str):
            index = self.accessors.index(index)
        ######################################################################
        # End backwards compatibility
        ######################################################################
        elif not isinstance(index, int):
            index = self._columns.index(index)
        else:
            # Re-interpret negative indices, and clip indices outside valid range.
            if index < 0:
                index = max(len(self._columns) + index, 0)
            else:
                index = min(len(self._columns), index)

        self._columns.insert(index, column)
        try:
            self._impl.insert_column(index, column)
        except TypeError:
            ######################################################################
            # 2026-02: Backwards compatibility for <= 0.5.3
            ######################################################################
            warnings.warn(
                "Tree implementations of insert_column should expect a column object "
                "not heading and accessor.",
                DeprecationWarning,
                stacklevel=2,
            )
            self._impl.insert_column(
                index, column.heading, getattr(column, "accessor", None)
            )
            ######################################################################
            # End backwards compatibility
            ######################################################################

    def remove_column(self, column: int | ColumnT[Value] | str) -> None:
        """Remove a tree column.

        :param column: The index of the column to remove, or the column (or its
            accessor [Deprecated]) to remove.
        """
        ######################################################################
        # 2026-02: Backwards compatibility for <= 0.5.3
        ######################################################################
        if isinstance(column, str):
            index = self.accessors.index(column)
        ######################################################################
        # End backwards compatibility
        ######################################################################
        elif not isinstance(column, int):
            index = self._columns.index(column)
        else:
            if column < 0:
                index = len(self._columns) + column
            else:
                index = column

        # Remove column
        del self._columns[index]
        self._impl.remove_column(index)

    @property
    def columns(self) -> list[ColumnT[Value]]:
        """The columns for the tree (read-only)"""
        return self._columns.copy()

    @property
    def show_headings(self) -> bool:
        """Whether or not the table shows a header at the top (read-only)"""
        return self._show_headings

    @property
    def headings(self) -> list[str] | None:
        """The column headings for the tree (read-only)"""
        print("here")
        if not self._show_headings:
            return None
        else:
            return [column.heading for column in self._columns]

    ######################################################################
    # 2026-02: Backwards compatibility for <= 0.5.3
    ######################################################################
    @property
    def accessors(self) -> list[str | None]:
        """The list of column accessors (read-only) [Deprecated]"""
        warnings.warn(
            "Using accessors is deprecated, use columns instead.",
            DeprecationWarning,
            stacklevel=2,
        )
        return [getattr(column, "accessor", None) for column in self._columns]

    ######################################################################
    # End backwards compatibility
    ######################################################################

    @property
    def missing_value(self) -> str:
        """The value that will be used when a data row doesn't provide a value for an
        attribute.
        """
        return self._missing_value

    @property
    def on_select(self) -> OnSelectHandler:
        """The callback function that is invoked when a row of the tree is selected."""
        return self._on_select

    @on_select.setter
    def on_select(self, handler: toga.widgets.tree.OnSelectHandler) -> None:
        self._on_select = wrapped_handler(self, handler)

    @property
    def on_activate(self) -> OnActivateHandler:
        """The callback function that is invoked when a row of the tree is activated,
        usually with a double click or similar action."""
        return self._on_activate

    @on_activate.setter
    def on_activate(self, handler: toga.widgets.tree.OnActivateHandler) -> None:
        self._on_activate = wrapped_handler(self, handler)
